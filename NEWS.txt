24.07.2014

1. Я исправил глюк с неправильным восстановлением функции на краях прямоугольника. Оказывается, причина была в неправильном вычислении значений функции, заданной таблицей. Линейная интерполяция тут не годится, функция получается разрывная, и маленькие погрешности в аргументе дают большие ошибки в значении. Использовал квадратичную интерполяцию, теперь работает нормально.

2. Проверил ещё раз качество восстановления функции по разности. Для функции на небольшом прямоугольнике (16 на 13 пикселей), принимающей значения от -1 до 1, восстановление по 1 паре разностей (т.е. с 1 сдвигом по x и по y) проходит теперь с максимальной погрешностью примерно 4%. По 2 парам разностей - примерно 2%. Попробовал добавить 3-ю пару разностей, 4-ю... но погрешность уменьшается всего на десятые доли процента.

3. Попробовал добавить к разностям случайный шум - нормально распределённый со среднеквадратичным отклонением 0.1 Увы, шум сильно ухудшает качество восстановления функции. Для 1 пары разностей получается максимальная погрешность порядка 40%, для 2 пар разностей - порядка 20%, а дальше уменьшается незначительно.

4. Сделал "интерферометрическую" функцию, то есть ту интенсивность света, которую выдаёт интерферометр. По файлам (которые output1i1.txt, output1i2.txt и т.п.) видно, что на картинке получатся горизонтальные и вертикальные полосы. Хорошо бы их визуализировать.

Попробовал восстановить функцию "в лоб", не определяя номеров полос. Восстановление не получилось - разность-то даже для исходной постоянной функции получается кусочно-постоянная. Соответственно программа говорит, что функций с такими разностями не бывает. :)

5. Начал делать восстановление границ полос. Ещё не доделал.

З.Ы. Новые интерферограммы ещё не смотрел.



6.08.2014

1. Начал делать восстановление функций, заданных не на прямоугольнике, а на произвольном множестве. Множество задаётся с помощью комбинации кругов и прямоугольников, которые можно поворачивать и смещать (все интерферограммы, которые я видел, можно задать таким образом). 

Пока что работает восстановление функции по разности на множествах, которые близки к выпуклым - можно назвать их "прямоугольно-выпуклыми". Практически любое множество можно задать как объединение прямоугольно-выпуклых. Например, кольцо, то есть разность двух кругов, если оно не очень тонкое - это объединение 4 прямоугольно-выпуклых множеств: соответственно левой верхней, левой нижней, правой верхней и правой нижней частей кольца. Далее можно будет восстанавливать функцию на объединении прямоугольно-выпуклых множеств, последовательно восстанавливая её на каждом компоненте. Я пока думаю, как максимально автоматизировать этот процесс, чтобы не задавать все множества вручную.


2. Сделал первый этап восстановления границ полос. Если оценивать границы по значению функции, её первой и второй производной, то условия получаются очень строгие - мало какие из границ им удовлетворяют. Если только по значению и первой производной, то восстанавливается больше. Если только по значению - восстанавливается ещё больше, но при маленьких значениях погрешности оказывается совсем неустойчиво к случайному шуму: при добавлении шума границы совсем перестают определяться, а при больших значениях погрешности - граница получается "толстой", состоящей не из 1 линии, а из 2-3. Дальше работать с толстой границей будет совсем неудобно. Так что на маленьких простеньких примерах наиболее эффективным получается восстановление по значению функции и 1-й производной.

Вообще-то, я тут подумал, что требования к исходной функции оказываются слишком ограничивающие. При восстановлении функции по разности предполагается только, что она удовлетворяет условию Гёльдера, а при определении полос требуется дифференцируемость, да не просто, а дважды дифференцируемость! Возможно, это неправильно (хотя, если функция на большей части области определения равна 0, то она там же и дважды дифференцируема, так что границы почти везде определятся правильно). Если не предполагать дважды дифференцируемости, то нельзя использовать 2-ю производную. Тогда при определении направления полос придётся оценивать градиенты по всем возможным направлениям. Если не предполагать дифференцируемости, то и градиент использовать нельзя - можно только брать вместо него конечные приращения функции и проверять, положительны они или отрицательны.


3. Посмотрел интерферограммы. На первый взгляд, ничего страшного. Пока не успел сделать закачивание из файлов - видимо, теперь займусь этим. Всё-таки, работоспособность алгоритма лучше оценивать на реальных примерах, а не искусственных. Наверно, начну с тех интерферограмм, которые заданы в кольце. 



13.08.2014

1. Сделал скачивание информации из файлов с картинками. В качестве множества используется кольцо - точнее, пока что верхняя левая его четверть (для определения полосок можно брать и кольцо целиком, просто дальше при восстановлении функции по разностям возникнут проблемы). Как я понял, там используется 256 интенсивностей серого цвета - то есть для диапазона от -1 до 1 точность определения величины равна 1/128. Правда, на некоторых картинка - например, 54.bmp - белого цвета как такового (то есть цвета интенсивности 255) нет, вместо него - светло-серенький с интенсивностью 229. Я решил, что диапазон цветов может быть разный, и сделал линейное преобразование к [-1; 1].

2. Обнаружил, что на многих картинках интенсивность цвета отнюдь не распределена по синусоиде - есть довольно большие области, где она минимальна или максимальна, то есть по всей области равна 1 или -1. Похоже, что значения интенсивности, которые больше или меньше некоторых пороговых значений, "срезаются". В такой области восстановление разности затруднительно. Но центр полосы всё равно как-то надо определить - проще всего провести его по центру области. Центр области можно определить так: это точка, для которой при движении вверх и вниз константы заканчиваются на равном расстоянии, и при движении вправо и влево константы заканчиваются тоже на равном расстоянии. Если область определения функции заканчивается раньше, чем заканчиваются константы, будем считать, что расстояния равные. Для горизонтальной, вертикальной или наклонной ровной полосы этот критерий в точности определяет центр полосы (правда, у нас-то все полосы неровные).

3. Сделал оценку максимумов и минимумов по картинке 54.bmp. Оценка не очень-то качественная - вместо линий получаются какие-то разбросанные "островки". Хотя на глаз видно, что "островки" вытянуты в вертикальные цепочки - вопрос, поймёт ли это алгоритм.

Может быть, кроме максимумов и минимумов, надо ещё оценивать и границы, на которых функция равна 0. На границах не происходит "срезание", поэтому их можно оценить точнее. Правда, для восстановления функции они нам не нужны - нужны-то как раз максимумы и минимумы. Но, возможно, границы помогут их локализовать, чтобы полосы друг с другом не пересекались. Подумаю над этим.

4. Еще проверил картинку 123_sphere_3. Там цепочки неплохо восстанавливаются. Правда, там и изображение более качественное.

5. Создал рабочую копию репозитория. Теперь буду все изменения коммитить в репозиторий https://github.com/hp279/interferometer.server


20.08.2014

1. Сделал коммит в репозиторий. Вроде бы, получилось. Правда, с моим тормозным Интернетом это сложно проверить.

2. Сделал оценку промежуточных значений, где функция равна 0. Правда, толку от этой оценки, по-моему, немного. На качественной картинке 123_sphere_3 промежуточные значения определяются хорошо, но там и без них можно обойтись. А на некачественной картинке 54 они определяются так же плохо, как минимумы и максимумы.:( Ну, может, чуть получше.

3. Нашёл библиотеку для работы с графами (она нам дальше понадобится). Называется jung. Там даже основные алгоритмы на графах есть.


29.08.2014

1. Додедал алгоритм вытягивания точек в линии - то бишь, оценки линий границ. Матрица вторых производных мне при этом не понадобилась. Я делал проще: брал каждую точку и проверял сперва её горизонтальных и вертикальных соседей, потом диагональных. Если есть 1 хороший сосед - присоединял его к границе, если 2 или больше - значит, в этом месте граница какая-то неопределённая, поэтому я сбрасывал в этой точке признак границы и считал, что здесь она заканчивается.

2. Проверил алгоритм на файлах 54 и 123_sphere_3. Результаты ожидаемые: в первом случае границы восстанавливаются плохо, во втором - хорошо. Существенной потери информации не заметил. Единственное, что огорчает: границы не следуют общей ориентации линий, которая видна невооружённым глазом. Они то завиваются кудряшками, то идут поперёк правильного направления. То есть в результате восстановления граница получится сильно изломанная. Подумаю над этим: может быть, матрица вторых производных и окажется полезной.



3.09.2014

1. Добавил нужные библиотеки:
collections-generic-4.0.1.jar (вспомогательные коллекции)
jung-api-2.0.1.jar (интерфейсы графов)
jung-graph-impl-2.0.1.jar (реализация графов)
jung-algorithms-2.0.1.jar (алгоритмы на графах)

2. Разобрался-таки с порядком перебора точек при восстановлении функции по разности. Сперва мне казалось, что перебирать точки методом обхода графа в ширину сложно, а если множество "хорошее" - например, является прямоугольником - можно построить алгоритмы перебора гораздо проще. В итоге выяснилось, что "хорошие множества" даже самого общего вида - прямоугольно-выпуклые, их горизонтальные и вертикальные объединения. В частности, к этому классу относится не только четверть кольца, но также верхняя и нижняя его половины.

3. Сделал восстановление границ для половины кольца для двух файлов 54 и 123_sphere_3. Восстановилось так же, как и четверть - никаких сюрпризов.)

P.S. Небольшое замечание по ориентации осей координат Ox и Oy. 
1) Математики, обычно, считают, что ось Ох направлена вправо, а ось Оу - вверх. 
2) При программировании графики, обычно, Ох направляют вправо, а Оу вниз. 
3) А при хранении матриц и при их изображении ось Ох (номер строки) идёт вниз, а Оу (номер столбца) - вправо: так удобнее записывать в файл и читать из файла (идёт внешний цикл по х, а внутренний - по у).

У меня везде в программе используется последний вариант (а в теоретическом описании алгоритма - первый). Только когда я читаю картинки из файла, идёт преобразование из "графической" ориентации оси координат в "матричную", чтобы в текстовом файле цифры располагались так же, как пиксели на картинке.


17.09.2014

1. Несколько уточнил алгоритм восстановления интерферометрических полос. Точнее, тот этап алгоритма, где соединяются края границ. Проще всего соединять их по прямой, но более эффективно - найдя кратчайшее соединение с помощью алгоритма Дейкстры или алгоритма А*. При этом длина дуги в соединении - это оценка того, насколько соответсвующая точка отклоняется от идеальной. 

2. Пока что реализовал соединение по прямым - только слегка корректирую направление прямых, исходя из оценки качества точек. При этом нужно соединять края, исходя из паросочетания минимальной стоимости в графе. Но я пока что соединяю от балды, первые попавшиеся.

3. Попробовал этот алгоритм соединения, как обычно, на файлах  54 и 123_sphere_3. В обоих случаях что-то соединяется правильно, что-то - с ошибками. Очевидно, без поиска паросочетаний минимальной стоимости не обойтись.


04.10.2014

1. Начал реализовывать соединение границ с помощью неориентированных графов (из библиотеки Jung). При этом довольно много кода пришлось переписать, но без графов никак не обойтись.

2. Уточнил алгоритм соединения линий. Нам ведь нужно соединить не только края линий между собой, но и ещё некоторые свободные края, не касающиеся границы области определения, надо продлить до границы. Поэтому строим граф, в котором вершины - краевые точки, а также для каждой краевой точки a - двойственная точка d(a), находящаяся как бы ``за пределами'' области определения. В графе будут ребра, соединяющие каждую точку a с d(a), стоимость p(a, d(a)) каждого из которых равна стоимости кратчайшего пути от a до границы.

Нам надо соединить все пары точек, чтобы каждая точка участвовала только в одном соединении - то есть построить паросочетание в графе. При этом суммарная стоимость соединений должна быть минимальной. Для этого каждому ребру (a, b) присвоим длину D - p(a, b), где D - достаточно большое число, превышающее суммарную стоимость всех ребер. Ищем паросочетание максимальной суммарной длины - оно, очевидно, будет затрагивать наибольшее возможное количество ребер (благодаря большому слагаемому D в длине каждого ребра), но при этом их суммарная стоимость будет минимально возможной.

3. Пока что алгоритм поиска максимального паросочетания не написал - он довольно сложный. Вместо этого пока написал более примитивный "жадный" алгоритм, который просто берёт каждую вершину, ищет к ней ближайшую и соединяет с ней.

4. Как обычно, опробовал алгоритм на двух файлах 54 и 123_sphere_3. У 123_sphere_3 большинство соединений правильно, но некоторые края не соединились, и есть несколько ошибочных соединений, которые идут "поперёк" полос. У 54 соединения - во все стороны без какой-либо системы. В общем, нужно делать поиск паросочетания максимальной стоимости.

5. Уточнил список ошибок, которые могут возникнуть при соединении границ:
А) Линия незамкнута и ее край не упирается в границу области определения функции.
Б) В одной точке сходится больше 2 линий.
В) Линии одного типа пересекаются (максимумы с максимумами, минимумы с минимумами, нули с нулями).
Г) Линии разных типов пересекаются.

Если для каждого типа найдено максимальное паросочетание, то возможна только ошибка Г (её надо будет устранять итеративно, уменьшая стоимости пересекающихся рёбер), остальных ошибок не должно быть. У произвольного паросочетания - в частности, находимого моим примитивным алгоритмом - возможна ещё ошибка А (ошибка Б невозможна по определению паросочетания). Ошибка В, вроде бы, невозможна, если правильно реализовывать кратчайшие соединения точек. По крайней мере, я ещё не видел, чтобы где-то была такая ошибка.


29.10.2014

1. Мы с Аней наконец-то занялись визуализацией. Пока что визуализируем границы (линии минимумов, максимумов и нулей) - сбрасываем в файл цветные линии поверх изображения. Это гораздо удобнее, чем просматривать громоздкие текстовые файлы.

2. Более-менее разобрался в алгоритме нахождения паросочетаний максимальной стоимости в графе. Алгоритм сложный, поэтому я решил реализовывать его по частям:
А) Алгоритм нахождения максимального паросочетания в двудольном графе.
В) Алгоритм нахождения максимального паросочетания в произвольном графе.
С) Алгоритм нахождения паросочетания максимальной стоимости в произвольном графе.

Алгоритм В) - это усложнённая версия алгоритма А), а С) использует В) в качестве вспомогательного алгоритма.

3. Реализовал алгоритм А). Вроде, даже работает. Правда, у нас граф потенциальных границ - не двудольный. Чтобы сделать из него двудольный, пришлось его немножко почистить, оставив только те границы, которые соединяют точки с чётной и нечётной первой координатой (впрочем, на уже найденных границах это хулиганство никак не сказалось, ибо паросочетание ищется среди потенциальных границ - то есть ещё не найденных).

4. Проверил алгоритм А) на реальных картинках. Результат получился для зашумлённой картинки ожидаемо низкого качества, а для хорошей картинки - получше, но неполный, с разрывами. Понятное дело, паросочетание - во-первых, не максимальное (ибо часть потенциальных границ, как уже сказано, была удалена), во-вторых, между собой соединяются какие попало точки. Нет проверки на близость точек - лишь бы между ними можно было провести границу.

Если реализовать алгоритм В), там ничего удалять не надо будет, поэтому паросочетание будет реально максимальным. А если реализовать алгоритм С), там уже будут в первую очередь соединяться более близкие точки, ибо это увеличит стоимость паросочетания. Этим я в ближайшее время и займусь.