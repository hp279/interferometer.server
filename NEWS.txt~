24.07.2014

1. Я исправил глюк с неправильным восстановлением функции на краях прямоугольника. Оказывается, причина была в неправильном вычислении значений функции, заданной таблицей. Линейная интерполяция тут не годится, функция получается разрывная, и маленькие погрешности в аргументе дают большие ошибки в значении. Использовал квадратичную интерполяцию, теперь работает нормально.

2. Проверил ещё раз качество восстановления функции по разности. Для функции на небольшом прямоугольнике (16 на 13 пикселей), принимающей значения от -1 до 1, восстановление по 1 паре разностей (т.е. с 1 сдвигом по x и по y) проходит теперь с максимальной погрешностью примерно 4%. По 2 парам разностей - примерно 2%. Попробовал добавить 3-ю пару разностей, 4-ю... но погрешность уменьшается всего на десятые доли процента.

3. Попробовал добавить к разностям случайный шум - нормально распределённый со среднеквадратичным отклонением 0.1 Увы, шум сильно ухудшает качество восстановления функции. Для 1 пары разностей получается максимальная погрешность порядка 40%, для 2 пар разностей - порядка 20%, а дальше уменьшается незначительно.

4. Сделал "интерферометрическую" функцию, то есть ту интенсивность света, которую выдаёт интерферометр. По файлам (которые output1i1.txt, output1i2.txt и т.п.) видно, что на картинке получатся горизонтальные и вертикальные полосы. Хорошо бы их визуализировать.

Попробовал восстановить функцию "в лоб", не определяя номеров полос. Восстановление не получилось - разность-то даже для исходной постоянной функции получается кусочно-постоянная. Соответственно программа говорит, что функций с такими разностями не бывает. :)

5. Начал делать восстановление границ полос. Ещё не доделал.

З.Ы. Новые интерферограммы ещё не смотрел.



6.08.2014

1. Начал делать восстановление функций, заданных не на прямоугольнике, а на произвольном множестве. Множество задаётся с помощью комбинации кругов и прямоугольников, которые можно поворачивать и смещать (все интерферограммы, которые я видел, можно задать таким образом). 

Пока что работает восстановление функции по разности на множествах, которые близки к выпуклым - можно назвать их "прямоугольно-выпуклыми". Практически любое множество можно задать как объединение прямоугольно-выпуклых. Например, кольцо, то есть разность двух кругов, если оно не очень тонкое - это объединение 4 прямоугольно-выпуклых множеств: соответственно левой верхней, левой нижней, правой верхней и правой нижней частей кольца. Далее можно будет восстанавливать функцию на объединении прямоугольно-выпуклых множеств, последовательно восстанавливая её на каждом компоненте. Я пока думаю, как максимально автоматизировать этот процесс, чтобы не задавать все множества вручную.


2. Сделал первый этап восстановления границ полос. Если оценивать границы по значению функции, её первой и второй производной, то условия получаются очень строгие - мало какие из границ им удовлетворяют. Если только по значению и первой производной, то восстанавливается больше. Если только по значению - восстанавливается ещё больше, но при маленьких значениях погрешности оказывается совсем неустойчиво к случайному шуму: при добавлении шума границы совсем перестают определяться, а при больших значениях погрешности - граница получается "толстой", состоящей не из 1 линии, а из 2-3. Дальше работать с толстой границей будет совсем неудобно. Так что на маленьких простеньких примерах наиболее эффективным получается восстановление по значению функции и 1-й производной.

Вообще-то, я тут подумал, что требования к исходной функции оказываются слишком ограничивающие. При восстановлении функции по разности предполагается только, что она удовлетворяет условию Гёльдера, а при определении полос требуется дифференцируемость, да не просто, а дважды дифференцируемость! Возможно, это неправильно (хотя, если функция на большей части области определения равна 0, то она там же и дважды дифференцируема, так что границы почти везде определятся правильно). Если не предполагать дважды дифференцируемости, то нельзя использовать 2-ю производную. Тогда при определении направления полос придётся оценивать градиенты по всем возможным направлениям. Если не предполагать дифференцируемости, то и градиент использовать нельзя - можно только брать вместо него конечные приращения функции и проверять, положительны они или отрицательны.


3. Посмотрел интерферограммы. На первый взгляд, ничего страшного. Пока не успел сделать закачивание из файлов - видимо, теперь займусь этим. Всё-таки, работоспособность алгоритма лучше оценивать на реальных примерах, а не искусственных. Наверно, начну с тех интерферограмм, которые заданы в кольце. 



13.08.2014

1. Сделал скачивание информации из файлов с картинками. В качестве множества используется кольцо - точнее, пока что верхняя левая его четверть (для определения полосок можно брать и кольцо целиком, просто дальше при восстановлении функции по разностям возникнут проблемы). Как я понял, там используется 256 интенсивностей серого цвета - то есть для диапазона от -1 до 1 точность определения величины равна 1/128. Правда, на некоторых картинка - например, 54.bmp - белого цвета как такового (то есть цвета интенсивности 255) нет, вместо него - светло-серенький с интенсивностью 229. Я решил, что диапазон цветов может быть разный, и сделал линейное преобразование к [-1; 1].

2. Обнаружил, что на многих картинках интенсивность цвета отнюдь не распределена по синусоиде - есть довольно большие области, где она минимальна или максимальна, то есть по всей области равна 1 или -1. Похоже, что значения интенсивности, которые больше или меньше некоторых пороговых значений, "срезаются". В такой области восстановление разности затруднительно. Но центр полосы всё равно как-то надо определить - проще всего провести его по центру области. Центр области можно определить так: это точка, для которой при движении вверх и вниз константы заканчиваются на равном расстоянии, и при движении вправо и влево константы заканчиваются тоже на равном расстоянии. Если область определения функции заканчивается раньше, чем заканчиваются константы, будем считать, что расстояния равные. Для горизонтальной, вертикальной или наклонной ровной полосы этот критерий в точности определяет центр полосы (правда, у нас-то все полосы неровные).

3. Сделал оценку максимумов и минимумов по картинке 54.bmp. Оценка не очень-то качественная - вместо линий получаются какие-то разбросанные "островки". Хотя на глаз видно, что "островки" вытянуты в вертикальные цепочки - вопрос, поймёт ли это алгоритм.

Может быть, кроме максимумов и минимумов, надо ещё оценивать и границы, на которых функция равна 0. На границах не происходит "срезание", поэтому их можно оценить точнее. Правда, для восстановления функции они нам не нужны - нужны-то как раз максимумы и минимумы. Но, возможно, границы помогут их локализовать, чтобы полосы друг с другом не пересекались. Подумаю над этим.

4. Еще проверил картинку 123_sphere_3. Там цепочки неплохо восстанавливаются. Правда, там и изображение более качественное.

5. Создал рабочую копию репозитория. Теперь буду все изменения коммитить в репозиторий https://github.com/hp279/interferometer.server


20.08.2014

1. Сделал коммит в репозиторий. Вроде бы, получилось. Правда, с моим тормозным Интернетом это сложно проверить.

2. Сделал оценку промежуточных значений, где функция равна 0. Правда, толку от этой оценки, по-моему, немного. На качественной картинке 123_sphere_3 промежуточные значения определяются хорошо, но там и без них можно обойтись. А на некачественной картинке 54 они определяются так же плохо, как минимумы и максимумы.:( Ну, может, чуть получше.

3. Нашёл библиотеку для работы с графами (она нам дальше понадобится). Называется jung. Там даже основные алгоритмы на графах есть.


29.08.2014

1. Додедал алгоритм вытягивания точек в линии - то бишь, оценки линий границ. Матрица вторых производных мне при этом не понадобилась. Я делал проще: брал каждую точку и проверял сперва её горизонтальных и вертикальных соседей, потом диагональных. Если есть 1 хороший сосед - присоединял его к границе, если 2 или больше - значит, в этом месте граница какая-то неопределённая, поэтому я сбрасывал в этой точке признак границы и считал, что здесь она заканчивается.

2. Проверил алгоритм на файлах 54 и 123_sphere_3. Результаты ожидаемые: в первом случае границы восстанавливаются плохо, во втором - хорошо. Существенной потери информации не заметил. Единственное, что огорчает: границы не следуют общей ориентации линий, которая видна невооружённым глазом: они то завиваются кудряшками, то идут поперёк правильного направления. То есть в результате восстановления граница получится сильно изломанная. Подумаю над этим: может быть, матрица вторых производных и окажется полезной.
